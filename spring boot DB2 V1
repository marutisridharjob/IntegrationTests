 Below is an example of a simple Spring Boot project that saves data into a DB2 table:

1. Create the Spring Boot Project

Use Spring Initializr to generate a Spring Boot project:
	•	Dependencies:
	•	Spring Web
	•	Spring Data JPA
	•	DB2 Driver
	•	Spring Boot DevTools (optional)


2. application.properties

Configure your DB2 database connection in src/main/resources/application.properties:


# DB2 Database Configuration
spring.datasource.url=jdbc:db2://<db-host>:<db-port>/<db-name>
spring.datasource.username=<db-username>
spring.datasource.password=<db-password>
spring.datasource.driver-class-name=com.ibm.db2.jcc.DB2Driver

# JPA Configuration
spring.jpa.database-platform=org.hibernate.dialect.DB2Dialect
spring.jpa.hibernate.ddl-auto=update

Replace <db-host>, <db-port>, <db-name>, <db-username>, and <db-password> with your DB2 instance details.

3. Entity Class

Create an entity that maps to your DB2 table (e.g., Person):


package com.example.db2demo.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Person {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private int age;

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}


4. Repository

Create a repository interface for CRUD operations:


package com.example.db2demo.repository;

import com.example.db2demo.entity.Person;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PersonRepository extends JpaRepository<Person, Long> {
}


5. Controller

Create a REST controller to handle requests:

package com.example.db2demo.controller;

import com.example.db2demo.entity.Person;
import com.example.db2demo.repository.PersonRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/persons")
public class PersonController {

    @Autowired
    private PersonRepository personRepository;

    // Save a new person
    @PostMapping
    public Person createPerson(@RequestBody Person person) {
        return personRepository.save(person);
    }

    // Get all persons
    @GetMapping
    public List<Person> getAllPersons() {
        return personRepository.findAll();
    }
}


6. Main Application

Your main application class (Db2DemoApplication.java):


package com.example.db2demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Db2DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(Db2DemoApplication.class, args);
    }
}


7. Create the DB2 Table

Make sure your DB2 table exists, or let Hibernate create it for you. If you’re creating it manually:


CREATE TABLE PERSON (
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NAME VARCHAR(100),
    AGE INT
);


8. Run the Application

	1.	Start the application:

mvn spring-boot:run


	2.	Use a tool like Postman or curl to test:
	•	Save a person:


curl -X POST http://localhost:8080/api/persons \
-H "Content-Type: application/json" \
-d '{"name":"John Doe","age":30}'



	•	Get all persons:

curl http://localhost:8080/api/persons

9. Expected Result

	•	The POST request saves a new record in the PERSON table.
	•	The GET request retrieves all records from the table.

This project demonstrates a simple setup for saving data into a DB2 table using Spring Boot and JPA. Let me know if you need additional features!


---------------

Yes, by default, Spring Boot uses transaction management with auto-commit enabled for database operations unless explicitly configured otherwise. Here’s a more detailed explanation:

Default Behavior in Spring Boot with JPA

	1.	Auto-commit Enabled:
	•	By default, when Spring Boot configures a datasource, it enables auto-commit mode. This means each SQL statement is committed immediately after execution unless a transaction boundary is defined.
	2.	Transactional Behavior:
	•	If you use methods provided by Spring Data JPA (e.g., save()), they run inside a transaction created by Spring.
	•	Spring manages the transaction lifecycle. When the method completes, the transaction is committed (if successful) or rolled back (if an exception occurs).


To Ensure Transactions for Multiple Operations

For scenarios where you need multiple operations to occur in a single transaction, you must explicitly define transaction boundaries using @Transactional.

Example:


package com.example.db2demo.service;

import com.example.db2demo.entity.Person;
import com.example.db2demo.repository.PersonRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class PersonService {

    private final PersonRepository personRepository;

    public PersonService(PersonRepository personRepository) {
        this.personRepository = personRepository;
    }

    @Transactional
    public void saveMultiplePersons() {
        Person person1 = new Person();
        person1.setName("Alice");
        person1.setAge(25);

        Person person2 = new Person();
        person2.setName("Bob");
        person2.setAge(30);

        personRepository.save(person1);
        personRepository.save(person2);

        // Uncomment to test rollback (simulating an exception)
        // if (true) throw new RuntimeException("Simulated exception!");
    }
}


Controlling Auto-Commit

You can disable auto-commit globally or let Spring handle transactions:
	1.	Disable Auto-Commit Globally:
Add the following to your application.properties:


spring.datasource.hikari.auto-commit=false


	2.	Spring Transaction Management:
Rely on Spring’s @Transactional annotation to manage commit and rollback boundaries, which will override the default auto-commit behavior.


Example: Rollback on Exception

If @Transactional is applied, Spring will:
	•	Commit the transaction if no exceptions occur.
	•	Roll back the transaction if an exception is thrown.

Test Case:


// In Controller or Service
try {
    personService.saveMultiplePersons();
} catch (Exception e) {
    System.out.println("Transaction Rolled Back: " + e.getMessage());
}


Result:

	•	If all operations succeed, data is saved.
	•	If an exception occurs, no data is saved (rollback).

Summary

	•	Auto-commit is enabled by default.
	•	For transactional control, use @Transactional to group operations and ensure atomicity (commit or rollback).
	•	Disabling auto-commit globally is usually unnecessary; rely on Spring’s transaction management instead.


-----------

To map a POJO to a table with a different name and columns that don’t match the POJO fields, you can use JPA annotations like @Table, @Column, and other mapping-related annotations. Here’s how you can achieve it:

Step-by-Step Example

Entity Class

package com.example.db2demo.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Column;
import jakarta.persistence.Id;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;

@Entity
@Table(name = "PERSON_TABLE")  // Map to the table with a different name
public class Person {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "PERSON_ID")  // Map to the column with a different name
    private Long id;

    @Column(name = "FULL_NAME")  // Map the POJO field 'name' to 'FULL_NAME'
    private String name;

    @Column(name = "PERSON_AGE")  // Map the POJO field 'age' to 'PERSON_AGE'
    private int age;

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}


Explanation of Annotations

	1.	@Entity:
	•	Marks this class as a JPA entity.
	2.	@Table(name = "PERSON_TABLE"):
	•	Maps the POJO to a table named PERSON_TABLE.
	3.	@Column(name = "FULL_NAME"):
	•	Maps the field name to the database column FULL_NAME.
	4.	@Id and @GeneratedValue:
	•	Marks the primary key of the table and specifies the generation strategy.


application.properties


# DB2 Database Configuration
spring.datasource.url=jdbc:db2://<db-host>:<db-port>/<db-name>
spring.datasource.username=<db-username>
spring.datasource.password=<db-password>
spring.datasource.driver-class-name=com.ibm.db2.jcc.DB2Driver

# JPA Configuration
spring.jpa.database-platform=org.hibernate.dialect.DB2Dialect
spring.jpa.hibernate.ddl-auto=update

Repository

package com.example.db2demo.repository;

import com.example.db2demo.entity.Person;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PersonRepository extends JpaRepository<Person, Long> {
}


Controller for Testing

package com.example.db2demo.controller;

import com.example.db2demo.entity.Person;
import com.example.db2demo.repository.PersonRepository;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/persons")
public class PersonController {

    private final PersonRepository personRepository;

    public PersonController(PersonRepository personRepository) {
        this.personRepository = personRepository;
    }

    // Save a new person
    @PostMapping
    public Person createPerson(@RequestBody Person person) {
        return personRepository.save(person);
    }

    // Get all persons
    @GetMapping
    public List<Person> getAllPersons() {
        return personRepository.findAll();
    }
}



Custom Table Example

SQL Table:

CREATE TABLE PERSON_TABLE (
    PERSON_ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    FULL_NAME VARCHAR(100),
    PERSON_AGE INT
);


Test the Application

	1.	Start the application:


mvn spring-boot:run



	2.	Use curl or Postman to test:
	•	POST a new person:

curl -X POST http://localhost:8080/api/persons \
-H "Content-Type: application/json" \
-d '{"name":"John Doe","age":30}'


	•	GET all persons:

curl http://localhost:8080/api/persons



The data will be saved in the PERSON_TABLE table with fields mapped correctly.



-----------


To save a list of Person objects to the database, you can use the saveAll method provided by Spring Data JPA. Here’s a code snippet:


Service Class to Save a List of Persons

package com.example.db2demo.service;

import com.example.db2demo.entity.Person;
import com.example.db2demo.repository.PersonRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class PersonService {

    private final PersonRepository personRepository;

    public PersonService(PersonRepository personRepository) {
        this.personRepository = personRepository;
    }

    // Method to save a list of Person objects
    public List<Person> savePersons(List<Person> persons) {
        return personRepository.saveAll(persons);  // Saves all persons to the database
    }
}


Controller Method to Accept a List of Persons


package com.example.db2demo.controller;

import com.example.db2demo.entity.Person;
import com.example.db2demo.service.PersonService;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/persons")
public class PersonController {

    private final PersonService personService;

    public PersonController(PersonService personService) {
        this.personService = personService;
    }

    // Endpoint to save a list of Person objects
    @PostMapping("/batch")
    public List<Person> savePersons(@RequestBody List<Person> persons) {
        return personService.savePersons(persons);
    }
}


Sample Request to Save a List of Persons

POST Request (JSON)

URL: http://localhost:8080/api/persons/batch


[
  {
    "name": "Alice",
    "age": 25
  },
  {
    "name": "Bob",
    "age": 30
  },
  {
    "name": "Charlie",
    "age": 35
  }
]


Expected Behavior

	•	The POST request will send a list of Person objects to the /batch endpoint.
	•	The savePersons method in the PersonService will persist all the objects to the database using saveAll.

Advantages of saveAll

	•	saveAll is optimized for batch inserts/updates.
	•	Ensures all objects are saved in a single transaction (if used with @Transactional).


Optional: Add Transaction Management

If you want to ensure the operation is atomic (all or nothing), annotate the savePersons method with @Transactional:

import org.springframework.transaction.annotation.Transactional;

@Service
public class PersonService {
    @Transactional
    public List<Person> savePersons(List<Person> persons) {
        return personRepository.saveAll(persons);
    }
}

If an exception occurs while saving, the entire batch will be rolled back.

----------------

Here’s an example using Spring Data JPA 3.4.0, which maps a table with different column names to a Java class. It includes configuration for Spring Boot 3.4.0 with Hibernate and how to map a table and its columns.

1. Maven pom.xml

Include the required dependencies in your pom.xml:

<dependencies>
    <!-- Spring Boot Starter Data JPA -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- DB2 Driver -->
    <dependency>
        <groupId>com.ibm.db2</groupId>
        <artifactId>jcc</artifactId>
        <version>11.5.7.0</version>
    </dependency>

    <!-- Spring Boot Starter Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>


2. Configure application.properties

Set up your DB2 database connection in src/main/resources/application.properties:

# DB2 Database Configuration
spring.datasource.url=jdbc:db2://<db-host>:<db-port>/<db-name>
spring.datasource.username=<db-username>
spring.datasource.password=<db-password>
spring.datasource.driver-class-name=com.ibm.db2.jcc.DB2Driver

# JPA Configuration
spring.jpa.database-platform=org.hibernate.dialect.DB2Dialect
spring.jpa.hibernate.ddl-auto=update
logging.level.org.hibernate.SQL=DEBUG

Replace <db-host>, <db-port>, <db-name>, <db-username>, and <db-password> with your DB2 instance details.


3. Map the Entity to a Table

Here’s how you map a Java class to a database table with custom column names.

Table Schema (Example)

CREATE TABLE PERSON_TABLE (
    PERSON_ID BIGINT NOT NULL PRIMARY KEY,
    FULL_NAME VARCHAR(100),
    PERSON_AGE INT
);

Entity Class

package com.example.demo.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "PERSON_TABLE") // Table mapping
public class Person {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "PERSON_ID") // Maps 'id' field to 'PERSON_ID'
    private Long id;

    @Column(name = "FULL_NAME") // Maps 'name' field to 'FULL_NAME'
    private String name;

    @Column(name = "PERSON_AGE") // Maps 'age' field to 'PERSON_AGE'
    private int age;

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}


4. Repository Interface

Define a Spring Data JPA repository to perform CRUD operations.


package com.example.demo.repository;

import com.example.demo.entity.Person;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PersonRepository extends JpaRepository<Person, Long> {
}

5. Service to Save Persons

Create a service layer to save or manage Person objects.


package com.example.demo.service;

import com.example.demo.entity.Person;
import com.example.demo.repository.PersonRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class PersonService {

    private final PersonRepository personRepository;

    public PersonService(PersonRepository personRepository) {
        this.personRepository = personRepository;
    }

    // Save a single person
    public Person savePerson(Person person) {
        return personRepository.save(person);
    }

    // Save a list of persons
    public List<Person> saveAllPersons(List<Person> persons) {
        return personRepository.saveAll(persons);
    }

    // Get all persons
    public List<Person> getAllPersons() {
        return personRepository.findAll();
    }
}


6. Controller

Create a REST controller to expose APIs for the above functionality.


package com.example.demo.controller;

import com.example.demo.entity.Person;
import com.example.demo.service.PersonService;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/persons")
public class PersonController {

    private final PersonService personService;

    public PersonController(PersonService personService) {
        this.personService = personService;
    }

    // Save a single person
    @PostMapping
    public Person savePerson(@RequestBody Person person) {
        return personService.savePerson(person);
    }

    // Save multiple persons
    @PostMapping("/batch")
    public List<Person> saveAllPersons(@RequestBody List<Person> persons) {
        return personService.saveAllPersons(persons);
    }

    // Get all persons
    @GetMapping
    public List<Person> getAllPersons() {
        return personService.getAllPersons();
    }
}


7. Test the Application

Start the application:

mvn spring-boot:run

Test using Postman or curl:

	•	Save a single person:

curl -X POST http://localhost:8080/api/persons \
-H "Content-Type: application/json" \
-d '{"name":"John Doe","age":30}'


	•	Save multiple persons:

curl -X POST http://localhost:8080/api/persons/batch \
-H "Content-Type: application/json" \
-d '[{"name":"Alice","age":25},{"name":"Bob","age":28}]'


	•	Get all persons:

curl http://localhost:8080/api/persons

8. Output

	•	The application will save data into the PERSON_TABLE in your DB2 database.
	•	The table fields will map to the POJO fields as per the @Column annotations.

This setup is fully functional with Spring Boot 3.4.0 and Spring Data JPA. Let me know if you face any issues!




